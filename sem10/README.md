# Семинар 10

## Дополнительные материалы

* [Компиляция программ без стандартной библиотеки Си (методичка 2020-21 года)](https://github.com/blackav/hse-caos-2020/tree/master/10-asm4#компиляция-программ-без-стандартной-библиотеки-си)
* [Ассемблерные вставки в программы на Си](https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html)

### Кратко про вставки

```text
    // синтаксис:
    asm (CODE : OUTPUTS : INPUTS : CLOBBERS);
        // CODE - ассемблерный код, записанный строкой,
        // причем %0, %1, %2 заменяются на аргументы (сначала outputs, потом inputs)
        // чтобы записать %, его нужно повторить дважды, например %%eax
        // OUTPUTS:
        // "=g" означает, что результат - это произвольное lvalue (т.е. то, чему в Си можно присваивать)
        // INPUTS:
        // "g" означает, что аргумент - это произвольное value
        // CLOBBERS - это список регистров и памяти, которые "портятся" в результате выполнения ассемблерного фрагмента
```

## Задачи на семинар

**NOTE** Не забываем, что вставки мы пишем на x86-ассемблере, поэтому и программы на Си надо компилировать с флагом `-m32`.

### A.c

Это пример демонстрирует, что ассемблерная вставка подставляется в текст программы на языке ассемблер (после трансляции) подобно макроподстановке. Ошибки компиляции проявляются позже.

Если транслировать на язык ассемблера

```text
gcc -m32 -S A.c -o A.S
```

то увидим текст из вставки внутри S-файла. Если попробовать скомпилировать

```text
gcc -m32 -c A.c
```

то получим ошибку компиляции.

### B.c

Написать функцию `get_ebx()`, которая будет возвращать текущее значение регистра `ebx`.
Вызвать эту функцию из другой ассемблерной вставки.

### C.c

Написать программу на Си, в которой будет вызывать рекурсивная функция. Из глубины рекурсии распечатать стек адресов возврата (получить что-то похожее на выполнение команды `bt` при работе с `gdb`).

### D.c

Программа должна распечатать в выходной поток всё содержимое входного потока.

**NB** Программа будет собираться без подключения стандартной библиотеки.
